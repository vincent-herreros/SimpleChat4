// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com package client;import common.*;import java.io.*;import java.util.Observable;import java.util.Observer;import com.lloseng.ocsf.client.ObservableClient;/** * This class overrides some of the methods defined in the abstract * superclass in order to give more functionality to the client. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave; * @author Fran&ccedil;ois B&eacute;langer * @version July 2000 */public class ChatClient implements Observer{	//Instance variables **********************************************	/**	 * The interface type variable.  It allows the implementation of 	 * the display method in the client.	 */	ChatIF clientUI; 	ObservableClient observableClient;	//Constructors ****************************************************	/**	 * Constructs an instance of the chat client.	 *	 * @param host The server to connect to.	 * @param port The port number to connect on.	 * @param clientUI The interface type variable.	 */	public ChatClient(String host, int port, ChatIF clientUI) 			throws IOException 			{		this.clientUI = clientUI;		observableClient = new ObservableClient(host, port);		observableClient.addObserver(this);		//openConnection();			}	//Instance methods ************************************************	/**	 * This method handles all data that comes in from the server.	 *	 * @param msg The message from the server.	 */	public void handleMessageFromServer(Object msg) 	{		if(msg.toString().startsWith("#"))		{			parseServerCommand(msg.toString().split(" "));		}		else		{			clientUI.display(msg.toString());		}	}	protected void parseServerCommand(String[] args)	{		String cmd = args[0].substring(1, args[0].length());		switch(cmd)		{		case "logoff":		{			try {				observableClient.closeConnection();			} catch (IOException e) {				clientUI.display("[console] Error : cannot disconnect from the server");			}			break;		}		}	}	/**	 * This method handles all data coming from the UI            	 *	 * @param message The message from the UI.    	 */	public void handleMessageFromClientUI(String message)	{		try		{			if(message.startsWith("#"))			{				parseCommand(message.split(" "));			}			else			{				//sendToServer(message);				observableClient.sendToServer(message);			}		}		catch(IOException e)		{			clientUI.display			("Could not send message to server.  Terminating client.");			quit();		}	}	/**	 * This method terminates the client.	 */	public void quit()	{		System.exit(0);	}	private void parseCommand(String[] args) throws IOException	{		String cmd = args[0].substring(1, args[0].length());		switch(cmd)		{		case "quit":		{			if(observableClient.isConnected())			{				observableClient.sendToServer("#logoff");				observableClient.closeConnection();			}			quit();			break;		}		case "logoff":		{			if(observableClient.isConnected())			{				observableClient.sendToServer("#logoff");				observableClient.closeConnection();			}			else			{				clientUI.display("[console] Error : not connected");			}			break;		}		case "sethost":		{			if(observableClient.isConnected())			{				clientUI.display("[console] Error : cannot set host if client is connected");			}			else			{				observableClient.setHost(args[1]);				if(args.length == 2)				{					clientUI.display("[console] Host has been set to " + args[1]);				}				else				{					clientUI.display("[console] Host has been set to " + args[1] + ", others arguments have been ignored.");				}			}			break;		}		case "setport":		{			if(observableClient.isConnected())			{				clientUI.display("[console] Error : cannot set port if client is connected");			}			else			{				int port = Integer.valueOf(args[1]);				observableClient.setPort(port);				if(args.length == 2)				{					clientUI.display("[console] Port has been set to " + args[1]);				}				else				{					clientUI.display("[console] Port has been set to " + args[1] + ", others arguments have been ignored.");				}			}			break;		}		case "login":		{			if(observableClient.isConnected())			{				clientUI.display("[console] Error : client is already connected");			}			else if(args.length < 2)			{				clientUI.display("[console] Error : #login needs username");			}			else			{				observableClient.openConnection();				observableClient.sendToServer("#login " + args[1]);			}			break;		}		case "gethost":		{			clientUI.display("[console] Host : " + observableClient.getHost());			break;		}		case "getport":		{			clientUI.display("[console] Port : " + observableClient.getPort());			break;		}		default:			clientUI.display("[console] Error : unknown command");		}	}	// Exceptions	protected void connectionException(Exception e)	{		clientUI.display("[console] Error : connection interrupted.");		e.printStackTrace();	}	protected void connectionClosed()	{		clientUI.display("[console] Connection closed.");	}		protected void connectionEstablished(){		clientUI.display("[console] Connection established");	}	@Override	public void update(Observable arg0, Object arg1) {		if(arg1 instanceof Exception)		{			connectionException((Exception)arg1);		}		else if(arg1.equals(ObservableClient.CONNECTION_ESTABLISHED))		{			connectionEstablished();		}		else if(arg1.equals(ObservableClient.CONNECTION_CLOSED))		{			connectionClosed();		}		else if(arg1 instanceof Object)		{			handleMessageFromServer(arg1);		}	}}//End of ChatClient class