package server;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import java.util.Observable;import java.util.Observer;import com.lloseng.ocsf.server.ConnectionToClient;import com.lloseng.ocsf.server.ObservableOriginatorServer;import com.lloseng.ocsf.server.ObservableServer;import com.lloseng.ocsf.server.OriginatorMessage;import common.ChatIF;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer{		ChatIF serverUI;		ObservableServer observableServer;		//Class variables *************************************************	/**	 * The default port to listen on.	 */	final public static int DEFAULT_PORT = 5555;	//Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 *	 * @param port The port number to connect on.	 * @throws IOException 	 */	public EchoServer(int port, ChatIF ui) throws IOException 	{		serverUI = ui;		observableServer = new ObservableOriginatorServer(port);		observableServer.addObserver(this);		observableServer.listen();	}	//Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 *	 * @param msg The message received from the client.	 * @param client The connection from which the message originated.	 */	public void handleMessageFromClient	(Object msg, ConnectionToClient client)	{		if(msg.toString().startsWith("#"))		{			parseClientCommand(msg.toString().split(" "), client);		}		else		{			if(client.getInfo("name") == null)			{				try {					client.sendToClient("[server] Error : username not known, connection refused");									client.close();				} catch (IOException e) {}			}			else			{				System.out.println("Message received: " + msg + " from " + client);				observableServer.sendToAllClients("[" + client.getInfo("name") + "] " + msg);			}		}		}		protected void parseClientCommand(String[] args, ConnectionToClient client)	{		String cmd = args[0].substring(1, args[0].length());				switch(cmd)		{		case "login":		{			if(client.getInfo("name") == null)			{				client.setInfo("name", args[1]);				serverUI.display("[console] " + client.getInfo("name").toString() + " is connected");				observableServer.sendToAllClients("[server] " + client.getInfo("name").toString() + " is connected");			}			else			{				try {					client.sendToClient("[server] Error : name already set");				} catch (IOException e) {}			}			break;		}		case "logoff":		{			try {				client.close();			} catch (IOException e) {}		}		}	}	protected void clientDisconnected(ConnectionToClient client) {		serverUI.display("[console] " + client.getInfo("name") + " is disconnected");		observableServer.sendToAllClients("[" + client.getInfo("name") + "] is disconnected");	}		protected void clientException(ConnectionToClient client, Throwable exception) {		serverUI.display("[console] Error on client " + client.getInfo("name"));		observableServer.sendToAllClients("[" + client.getInfo("name") + "] has been disconnected");	}			/**	 * This method overrides the one in the superclass.  Called	 * when the server starts listening for connections.	 */	protected void serverStarted()	{		System.out.println		("Server listening for connections on port " + observableServer.getPort());	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server stops listening for connections.	 */	protected void serverStopped()	{		System.out.println		("Server has stopped listening for connections.");	}	public void handleMessageFromServerUI(String message)	{		if(message.startsWith("#"))		{			parseCommand(message.split(" "));		}		else		{			observableServer.sendToAllClients("[server] " + message);		}	}		public void parseCommand(String[] args)	{		String cmd = args[0].substring(1, args[0].length());		switch(cmd)		{		case "quit":		{			observableServer.sendToAllClients("#logoff");			try {				observableServer.close();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}			System.exit(0);			break;		}		case "stop":		{			observableServer.stopListening();			System.out.println("[console] Server listening stopped");			//sendToAllClients("[server] Stopped listening for new clients");			break;		}		case "close":		{			try {				observableServer.sendToAllClients("[server] Closing...");				observableServer.sendToAllClients("#logoff");				observableServer.close();				System.out.println("[console] Server stopped");			} catch (IOException e) {}			break;		}		case "setport":		{			if(observableServer.isListening())			{				System.out.println("[console] Error : cannot set port if server is listening");			}			else			{				int port = Integer.valueOf(args[1]);				observableServer.setPort(port);				if(args.length == 2)				{					System.out.println("[console] Port has been set to " + args[1]);				}				else				{					System.out.println("[console] Port has been set to " + args[1] + ", others arguments have been ignored.");				}			}			break;		}		case "start":		{			if(observableServer.isListening())			{				System.out.println("[console] Error : server already started");			}			else			{				try {					observableServer.listen();					System.out.println("[console] : Server started");				} catch (IOException e) {					System.err.println("[console] Error : cannot listen for clients");				}			}			break;		}		case "getport":		{			System.out.println("[console] Server listening on port " + observableServer.getPort());			break;		}		default:		{			System.out.println("[console] Error : unknown command");		}		}	}	//Class methods ***************************************************	/**	 * This method is responsible for the creation of 	 * the server instance (there is no UI in this phase).	 *	 * @param args[0] The port number to listen on.  Defaults to 5555 	 *          if no argument is entered.	 */	public static void main(String[] args) 	{		int port = 0; //Port to listen on		try		{			port = Integer.parseInt(args[0]); //Get port from command line		}		catch(Throwable t)		{			port = DEFAULT_PORT; //Set port to 5555		}				try 		{			@SuppressWarnings("unused")			EchoServer sv = new EchoServer(port, null);		} 		catch (Exception ex) 		{			System.out.println("ERROR - Could not listen for clients!");		}	}	@Override	public void update(Observable arg0, Object arg1) {		OriginatorMessage om = (OriginatorMessage)arg1;		if(om.getMessage().equals(ObservableServer.CLIENT_CONNECTED))		{			clientConnected(om.getOriginator());		}		else if(om.getMessage().equals(ObservableServer.CLIENT_DISCONNECTED))		{			clientDisconnected(om.getOriginator());		}		else if(om.getMessage().toString().startsWith(ObservableServer.CLIENT_EXCEPTION))		{			clientException(om.getOriginator(), new Exception(om.getMessage().toString().substring(ObservableServer.CLIENT_EXCEPTION.toString().length())));		}		else if(om.getMessage().equals(ObservableServer.LISTENING_EXCEPTION))		{			listeningException(new Exception(om.getMessage().toString().substring(ObservableServer.CLIENT_EXCEPTION.toString().length())));		}		else if(om.getMessage().equals(ObservableServer.SERVER_CLOSED))		{			serverClosed();		}		else if(om.getMessage().equals(ObservableServer.SERVER_STARTED))		{			serverStarted();		}		else if(om.getMessage().equals(ObservableServer.SERVER_STOPPED))		{			serverStopped();		}		else		{			handleMessageFromClient(om.getMessage(), om.getOriginator());		}	}		  protected void clientConnected(ConnectionToClient client)	  {	  }	  protected void listeningException(Throwable exception)	  {		  serverUI.display("[console] Error on listening");	  }	  protected void serverClosed()	  {		  serverUI.display("[console] Server closed");	  }}//End of EchoServer class